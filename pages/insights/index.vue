<template>
  <Page>
    <Card title="⏰ Churn History" :isLoading="!churnHistory">
      <vue-good-table
        v-if="churnHistory"
        :columns="cols"
        :rows="churnHistory"
        styleClass="vgt-table net-table bordered"
        :pagination-options="{
          enabled: true,
          perPage: 30,
          perPageDropdownEnabled: false,
        }"
      >
        <template slot="table-row" slot-scope="props">
          <span v-if="props.column.field == 'timestamp'">
            {{timeFormat(props.row.timestamp)}}
            <span style="font-size: .75rem;">
              ({{fromNow(props.row.timestamp)}})
            </span>
          </span>
          <span v-else>
            {{props.formattedRow[props.column.field]}}
          </span>
        </template>
      </vue-good-table>
      <span class="footer">
        Powered By <strong>Multipartite</strong>
      </span>
    </Card>
    <Card title="🔒 Total Value Locked (from Flipside)">
      <VChart v-if="tvlOption" class="chart" :option="tvlOption" :loading="!tvlOption" :autoresize="true"></VChart>
    </Card>
    <Card title="💰 Rune Price History (from Flipside)">
      <VChart v-if="runePriceOption" :option="runePriceOption" :loading="!runePriceOption" :autoresize="true"></VChart>
    </Card>
    <Card title="📊 Swap Count Chart (from Flipside)">
      <VChart v-if="swapCountChart" :option="swapCountChart" :loading="!swapCountChart" :autoresize="true"></VChart>
    </Card>
  </Page>
</template>

<script>
import moment from "moment";
import { momentTimeFormat, runeCur } from '~/utils';
import _ from "lodash";

import { use } from "echarts/core";
import { SVGRenderer } from "echarts/renderers";
import { LineChart, BarChart, CandlestickChart } from "echarts/charts";
import {
  TitleComponent,
  TooltipComponent,
  LegendComponent,
  GridComponent,
  DataZoomComponent
} from "echarts/components";
import VChart from "vue-echarts";

use([
  SVGRenderer,
  GridComponent,
  LineChart,
  BarChart,
  CandlestickChart,
  TitleComponent,
  TooltipComponent,
  DataZoomComponent,
  LegendComponent
]);

export default {
  components: {
    VChart
  },
  data() {
    return {
      churnHistory: undefined,
      cols: [
        {
          label: 'Churn Occurred',
          field: 'timestamp',
        },
        {
          label: 'Block ID',
          field: 'BLOCK_ID',
          type: 'number',
          tdClass: 'mono',
          formatFn: this.normalFormat
        },
        {
          label: 'Churn Length (days)',
          field: 'DAYS_SINCE_LAST_CHURN',
          type: 'number',
          tdClass: 'mono',
        }
      ],
      tvlOption: undefined,
      runePriceOption: undefined,
      swapCountChart: undefined
    }
  },
  mounted() {
    this.$api.getChurnHistory().then(({data}) => {
      this.churnHistory = data.map(d => ({...d, timestamp: moment(d.BLOCK_TIMESTAMP)}));;
    }).catch(e => {
      console.error(e);
    })

    this.$api.getFlipTVL().then(({data}) => {
      this.flipTVLFormat(data);
    }).catch(e => {
      console.error(e);
    })

    this.$api.getRunePrice().then(({data}) => {
      this.runePriceFormat(data);
    }).catch(e => {
      console.error(e);
    })

    this.$api.getDailySwap().then(({data}) => {
      this.dailySwapFormat(data);
    }).catch(e => {
      console.error(e);
    })
  },
  methods: {
    timeFormat(time) {
      return momentTimeFormat(time)
    },
    fromNow(time) {
      return moment(time)?.fromNow();
    },
    flipTVLFormat(d) {
      let xAxis = [];
      let tvp = [];
      let tvl = [];
      let tvb = [];
      d.forEach(interval => {
        xAxis.push(moment(interval.DAY).format("YY/MM/DD"));
        tvp.push(interval.TOTAL_VALUE_POOLED);
        tvl.push(interval.TOTAL_VALUE_LOCKED);
        tvb.push(interval.TOTAL_VALUE_BONDED);
      });

      let option = {
        title: {
          show: false,
        },
        tooltip: {
          confine: true,
          trigger: "axis",
          valueFormatter: (value) => `${this.normalFormat(value)} ${runeCur()}`
        },
        legend: {
          x: 'center',
          y: 'bottom',
          icon: 'rect',
          textStyle: {
            color: "var(--font-color)"
          }
        },
        xAxis: {
          data: xAxis.reverse(),
          boundaryGap: false,
          splitLine: {
            show: false,
          },
          axisLine: {
            lineStyle: {
              color: 'var(--font-color)'
            }
          },
          axisLabel: {
            color: 'var(--font-color)',
            fontFamily: 'ProductSans',
          }
        },
        yAxis: {
          show: false,
        },
        grid: {
          left: '20px',
          right: '20px'
        },
        series: [
          {
            type: 'line',
            name: 'Total Value Locked (In Rune)',
            showSymbol: false,
            data: tvl.reverse(),
            smooth: true
          },
          {
            type: 'line',
            name: 'Total Value Pooled (In Rune)',
            showSymbol: false,
            data: tvp.reverse(),
            smooth: true
          },
          {
            type: 'line',
            name: 'Total Value Bonded (In Rune)',
            showSymbol: false,
            data: tvb.reverse(),
            smooth: true
          }
        ]
      };

      this.tvlOption = option;
    },
    runePriceFormat(d) {
      let xAxis = [];
      let runePrice = [];
      let volume = [];
      let lastDate = undefined;
      let sameDay = [];
      d.forEach(interval => {
        let date = moment(interval.DATE);
        if (!lastDate) {
          lastDate = date;
        }
        if (date.isSame(lastDate, 'day')) {
          sameDay.push({date, price: interval.DAILY_RUNE_PRICE});
        }
        else {
          let minPrice = _.min(sameDay.map(d => d.price))
          let maxPrice = _.max(sameDay.map(d => d.price))
          let closePrice = sameDay[0].price
          let openPrice = sameDay[0].price
          let minM = sameDay[0].date
          let maxM = sameDay[0].date
          let vol = 0
          sameDay.forEach((d, i) => {

            if (d.date.isBefore(minM)) {
              minM = d.date
              openPrice = d.price
            }
            if (d.date.isAfter(maxM)) {
              maxM = d.date
              closePrice = d.price
            }
            if (d.vol) {
              vol = d.vol;
            }
          })
          runePrice.push([openPrice, closePrice, minPrice, maxPrice])
          xAxis.push(moment(date).format("YY/MM/DD"))
          volume.push(vol)

          // add the new date
          lastDate = undefined;
          sameDay = [];
          sameDay.push({date, price: interval.DAILY_RUNE_PRICE, vol: interval.TOTAL_SWAP_VOLUME_USD});
        }
      });

      let option = {
        title: {
          show: false,
        },
        tooltip: {
          confine: true,
          trigger: "axis",
          axisPointer: {
            type: 'cross'
          }
        },
        legend: {
          show: false,
          x: 'center',
          y: 'bottom',
          icon: 'rect',
          textStyle: {
            color: "var(--font-color)"
          }
        },
        dataZoom: [
          {
            type: 'inside',
            start: 50,
            end: 100
          },
          {
            show: true,
            type: 'slider',
            top: '90%',
            start: 50,
            end: 100
          }
        ],
        xAxis: {
          data: xAxis,
          boundaryGap: false,
          splitLine: {
            show: false,
          },
          axisLine: {
            lineStyle: {
              color: 'var(--font-color)'
            }
          },
          axisLabel: {
            color: 'var(--font-color)',
            fontFamily: 'ProductSans',
          }
        },
        yAxis: [
          {
            axisLine: {
              lineStyle: {
                color: 'var(--font-color)'
              }
            },
            splitLine: {
              lineStyle: {
                color: 'var(--border-color)'
              }
            }
          },
          {
            show: false,
            max: 1e9
          }
        ],
        grid: {
          left: '20px',
          right: '20px'
        },
        series: [
          {
            type: 'candlestick',
            name: 'Rune Price',
            data: runePrice,
            itemStyle: {
              color: "green",
              color0: "#c23531",
              borderColor: 'green',
              borderColor0: '#c23531'
            }
          },
          {
            name: 'Thorchain Trade Volume',
            type: 'bar',
            data: volume,
            yAxisIndex: 1,
            itemStyle: {
              color: '#2962ff'
            },
          }
        ]
      };

      this.runePriceOption = option;
    },
    dailySwapFormat(d) {
      let xAxis = [];
      let swapCount = [];
      let cumSwapCount = [];
      let uniqueSwapperCount = [];
      d.forEach(interval => {
        xAxis.push(moment(interval.DATE).format("YY/MM/DD"));
        swapCount.push(interval.SWAP_COUNT);
        cumSwapCount.push(interval.SWAP_COUNT_CUMULATIVE)
        uniqueSwapperCount.push(interval.UNIQUE_SWAPERS)
      });

      let option = {
        title: {
          show: false,
        },
        tooltip: {
          confine: true,
          trigger: "axis",
        },
        legend: {
          x: 'center',
          y: 'bottom',
          icon: 'rect',
          textStyle: {
            color: "var(--font-color)"
          }
        },
        xAxis: {
          data: xAxis,
          boundaryGap: false,
          splitLine: {
            show: false,
          },
          axisLine: {
            lineStyle: {
              color: 'var(--font-color)'
            }
          },
          axisLabel: {
            color: 'var(--font-color)',
            fontFamily: 'ProductSans',
          }
        },
        yAxis: [
          {
            show: false,
          },
          {
            show: false,
          }
        ],
        grid: {
          left: '20px',
          right: '20px'
        },
        series: [
          {
            type: 'bar',
            name: 'Swap Count',
            yAxisIndex: 0,
            showSymbol: false,
            data: swapCount,
            smooth: true
          },
          {
            type: 'bar',
            name: 'Unique Swappers Count',
            yAxisIndex: 0,
            showSymbol: false,
            data: uniqueSwapperCount,
            smooth: true
          },
          {
            type: 'line',
            name: 'Cumluative Swap Count',
            yAxisIndex: 1,
            showSymbol: false,
            data: cumSwapCount,
            smooth: true
          },
        ]
      };

      this.swapCountChart = option;
    }
  }
}
</script>

<style lang="scss">
.footer {
  display: block;
  margin: 1rem 0 .3rem .5rem;
}

.echarts {
  width: 100%;
  height: 400px;
}

.legend-item {
  display: flex;
  align-items: center;
  font-size: .8rem;
  padding: 0 .1rem;

  .legend-fill {
    width: 5px;
    height: 5px;
    border-radius: 50%;
    margin-right: 5px;
  }

  .value {
    font-weight: bold;
    margin-left: 5px;
  }
}
</style>
